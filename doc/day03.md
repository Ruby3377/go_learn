# 位运算

针对的是二进制

| 运算符 |                             描述                             |
| :----: | :----------------------------------------------------------: |
|   &    |    参与运算的两数各对应的二进位相与。 （两位均为1才为1）     |
|   \|   |  参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）   |
|   ^    | 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1） |
|   <<   | 左移n位就是乘以2的n次方。 “a<<b”是把a的各二进位全部左移b位，高位丢弃，低位补0。 |
|   >>   | 右移n位就是除以2的n次方。 “a>>b”是把a的各二进位全部右移b位。 |



# 数组初始化

数组长度是类型的一部分

```go
// 数组初始化1
var b1 [3]bool
// 数组赋值
b1 = [3]bool{false, true, true}
fmt.Printf("%T\n", b1)

// 数组初始化2
b2 := [2]bool {false,true}
fmt.Printf("%v\n", b2)

// 数组初始化3：根据初始值自动推断数组长度
b3 := [...]int{0, 1, 2, 3}
fmt.Printf("值::%v，类型::%T\n", b3, b3)

// 数组初始化4：不给的值使用默认值
b4 := [5]int{0, 1}
fmt.Printf("值::%v，类型::%T\n", b4, b4)

// 数组初始化5：根据索引来初始化
b5 := [5]int{0: 0, 3: 1}
fmt.Printf("值::%v，类型::%T\n", b5, b5)
```

# 数组遍历

```go
// 数组遍历
d1 := [...]int{0, 1, 2, 9}
for i := 0; i < len(d1); i += 1 {
fmt.Printf("当前索引::%v 值::%v", i, d1[i])
}
```

Range遍历

```go
for i, v := range d1 {
	fmt.Printf("Range遍历当前索引::%v 值::%v", i, v)
}
```

多维数组

```go
d3 := [3][2]int{{0, 2}, {9, 2}, {7, 3}}
for i, v := range d3 {
	fmt.Printf("多维遍历当前索引::%v 值::%v", i, v)
}
```

练习：找出和为5的两个下标{2,1,4,5,3}

```go
d4 := [...]int{2, 1, 4, 5, 3}
for i := 0; i < len(d4); i++ {
	for j := i + 1; j < len(d4); j++ {
		if d4[i]+d4[j] == 5 {
			fmt.Printf("(i::%v,,j::%v)\n", i, j)
		}
	}
}
```

# 切片

完整：https://www.liwenzhou.com/posts/Go/06_slice/

```go
a1 := [...]int{2, 4, 5, 9, 2}
s1 := a1[1:3] //从1切到3但不包含3
s2 := a1[1:]  //从1切到最后
s3 := a1[:3]  //从最开始切到3
fmt.Println(s1)
fmt.Println(s2)
fmt.Println(s3)
```

切片的容量为切片开始位置到数组的长度，

##### 本质

切片就是一个框，框住了一块连续内存。

切片属于引用类型，真正的数据其实都是保存在底层数组里的。

##### 判断

要判断一个切片是否为空需要用len(s) == 0来判断长度是否等于空，不应该使用s == nil来判断。

### 切片内部逻辑

![image-20200911115418624](/Users/q1/Library/Application Support/typora-user-images/image-20200911115418624.png)

### 切片中删除数值

删除下标为2的值

```go
a2 := []int{6, 1, 2}
fmt.Println(a1)
a2 = append(a2[:1], a2[2:]...)
fmt.Println(a1)
```

打印

```
[6 1 2]
[6 2]
```









